#!/bin/bash

# DoVI XML parser retourne dans un fichier texte des atoms predictifs d'un XML géneré par DaVinci 
# contenant toutes les informations metadatas Dolby Vision d'une timeline
# DoVI XML parser permet aussi de réaliser des test logiques sur le contenu de l'XML
INPUTXML=$1
XML=$(cat $INPUTXML)
OLDIFS="$IFS"

# FUNCTIONS
parseXML()
{
  local XPATH=$1
  echo "$XML" | xmllint --xpath "$XPATH" -
}

# trimTags()
# {
  # sed 's/<.*>\(.*\)<\/.*>/\1/' "$1"
# }



# Revision history#


#---- is this a revised version ? (number of <revision> node. if 1 it is the fisrt version ever generated
#---- if not, display last history by DATE/AUTHOR/SOFTWARE/SOFTWAREVERSION
# MODIFIEDDATE=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/DateTime")
# AUTHOR=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/Author")
# SOFTWARE=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/Software")
# SOFTWAREV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/SoftwareVersion")
# [ $REVISIONCOUNT = 1 ] && echo "This is the first version ever generated by this software: $AUTHOR -- $SOFTWARE -- $SOFTWAREV on $MODIFIEDDATE" 
#---- if it is, display all history by HISTORYNUMBER/DATE/AUTHOR/SOFTWARE/SOFTWAREVERSION

# let I=1
# if [ $REVISIONCOUNT > 1 ]; then
  # echo "There are $REVISIONCOUNT version:"
  # while [ $I -le $REVISIONCOUNT ]
    # do
    # MODIFIEDDATEnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/DateTime")
    # AUTHORnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/Author")
    # SOFTWAREnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/Software")
    # SOFTWAREVnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/SoftwareVersion")
    # echo "DoVI color mapping saved version $I generated on $MODIFIEDDATEnV by: $AUTHORnV -- $SOFTWAREnV -- $SOFTWAREVnV" 
    # let I=I+1
  # done
# fi
REVISIONCOUNT=$(parseXML "count(/DolbyLabsMDF/RevisionHistory/Revision)")

IFS=$'\n'
SOFTWAREVS=($(parseXML "/DolbyLabsMDF/RevisionHistoryRevision/Software/text()"))
MODIFIEDDATEVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/DateTime/text()"))
AUTHORVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/Author/text()"))
SOFTWAREVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/Software/text()"))
SOFTWAREVERSIONVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/SoftwareVersion/text()"))
IFS=$OLDIFS

let I=1
if [ $REVISIONCOUNT > 1 ]; then
  echo "There are $REVISIONCOUNT versions:"
  while [ $I -le $REVISIONCOUNT ]
    do
    echo "DoVI metadata XML's version file number $I generated on ${MODIFIEDDATEVS[((I-1))]} by: ${AUTHORVS[((I-1))]} -- ${SOFTWAREVS[((I-1))]} -- ${MODIFIEDDATEVS[((I-1))]}"
    let I=I+1
    done
  else
  echo " This is the first version of the DoVI metadata XML's file generated on ${MODIFIEDDATEVS[last()]} by: ${AUTHORVS[last()]} -- ${SOFTWAREVS[last()]} -- ${MODIFIEDDATEVS[last()]}"
fi


#---- Outputs

# nom de la metadata Outputs/Output[name=.*]
METADATANAME=$(parseXML "/DolbyLabsMDF/Outputs/Output/@name" | sed 's/name="\(.*\)"$/\1/')
echo "DoVi CM metadata filename is: $METADATANAME"
# version de la metadata (2.0.5, 4.0.2 ...)
CMV=$(parseXML "/DolbyLabsMDF/@version" | sed 's/.*="\([0-9.]*\)".*/\1/')
echo "Metadata version is CMv=$CMV"
# param cadre diffuser (à afficher et convertir en ligne*pix) Outputs/output/CanvasAspectRatio
CANVASASPECTRATIO=$(parseXML "/DolbyLabsMDF/Outputs/Output/CanvasAspectRatio/text()")
echo "Canvas aspect ratio is: $CANVASASPECTRATIO"  
# param cadre util (à afficher et convertir en ligne*pix) Outputs/output/ImageAspectRatio
IMAGEASPECTRATIO=$(parseXML "/DolbyLabsMDF/Outputs/Output/ImageAspectRatio/text()")
echo "Image aspect ratio is: $IMAGEASPECTRATIO" 
# Outputs/Output/video/rate   cadence image de la metadata(<n>f</n>p<d>s</d>)
METAFRAMERATEN=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/Rate/n/text()")
METAFRAMERATED=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/Rate/d/text()")
let METAFRAMERATE="METAFRAMERATEN / METAFRAMERATED"
echo "DoVi metadatas are set at $METAFRAMERATE fps"
#Outputs/Output/video/ColorEncoding/Primaries/Red /Green /Blue (arg: x,y) déclaration des extremes colorimétriques du VDM
SOURCECOLORSPACER=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Primaries/Red/text()")
SOURCECOLORSPACEG=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Primaries/Green/text()")
SOURCECOLORSPACEB=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Primaries/Blue/text()")
#4 Scenaris based on 3 color space REC703, P3, REC 2020, Unknown
SOURCECOLORSPACERx=$(echo $SOURCECOLORSPACER | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACERy=$(echo $SOURCECOLORSPACER | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACER="$SOURCECOLORSPACERx"",""$SOURCECOLORSPACERy"

SOURCECOLORSPACEGx=$(echo $SOURCECOLORSPACEG | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEGy=$(echo $SOURCECOLORSPACEG | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEG="$SOURCECOLORSPACEGx"",""$SOURCECOLORSPACEGy"

SOURCECOLORSPACEBx=$(echo $SOURCECOLORSPACEB | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEBy=$(echo $SOURCECOLORSPACEB | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEB="$SOURCECOLORSPACEBx"",""$SOURCECOLORSPACEBy"
echo "Picture source declared primaries chromaticities coordinates are:"
echo "R(x,y) $SOURCECOLORSPACER"
echo "G(x,y) $SOURCECOLORSPACEG"
echo "B(x,y) $SOURCECOLORSPACEB"
[ "$SOURCECOLORSPACER" == "0.64,0.33" ] && [ "$SOURCECOLORSPACEG" == "0.3,0.6" ] && [ "$SOURCECOLORSPACEB" == "0.15,0.06" ] && SOURCECOLORSPACE="REC709" && echo "Picture source is declared for a REC.709 master target display." 
[ "$SOURCECOLORSPACER" == "0.68,0.32" ] && [ "$SOURCECOLORSPACEG" == "0.265,0.69" ] && [ "$SOURCECOLORSPACEB" == "0.15,0.06" ] && SOURCECOLORSPACE="P3" && echo "Picture source is declared for a P3 master target display." 
[ "$SOURCECOLORSPACER" == "0.708,0.292" ] && [ "$SOURCECOLORSPACEG" == "0.17,0.797" ] && [ "$SOURCECOLORSPACEB" == "0.131,0.046" ] && SOURCECOLORSPACE="REC2020" && echo "Picture source is declared for a REC.2020 master target display."
[ "$SOURCECOLORSPACE" != "REC709" ] && [ "$SOURCECOLORSPACE" != "P3" ] && [ "$SOURCECOLORSPACE" != "REC2020" ] && echo "Unknown color primaries declaration" && SOURCECOLORSPACE="NA"

# à determiner par rapport au diagramme de chromaticité 1331 (P3 BT.2020 REC.709, Unknown)
#Outputs/Output/video/ColorEncoding/WhitePoint coordonée point blanc (arg:x,y) à pointer et determiner selon Chrom 1331 (D65,D60, DCI, unknown)
SOURCEWHITEPOINT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/WhitePoint/text()")
SOURCEWHITEPOINTx=$(echo $SOURCEWHITEPOINT | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCEWHITEPOINTy=$(echo $SOURCEWHITEPOINT | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCEWHITEPOINT="$SOURCEWHITEPOINTx"",""$SOURCEWHITEPOINTy"
echo "Picture source declared white point chromaticities coordinates are: $SOURCEWHITEPOINT"
[ "$SOURCEWHITEPOINT" == "0.3127,0.329" ] && echo "Picture source is declared for a D65 white point master target display."	
[ "$SOURCEWHITEPOINT" != "0.3127,0.329" ] && echo "Picture source white point declaration is not clearly identified."
#Outputs/Output/video/ColorEncoding/Encoding doit être identifié en "PQ" (Perceptual Quantizer)
SOURCEEOTF=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Encoding/text()")
echo "Picture source declared EOTF is: $SOURCEEOTF"
[ "$SOURCEEOTF" != "pq" ] && echo "Picture source declared EOTF ($SOURCEEOTF) is not compliant with Dolby Vision CM workflow."
#Outputs/Output/video/ColorEncoding/<MinimumBrightness>0 (echelle absolue de la dynamique du luminance idéale dit être inférieur à 1nits)
#Outputs/Output/video/ColorEncoding/<PeakBrightness>10000 (echelle absolue de la dynamique du luminance idéale doit être égale à 10000nits)
SOURCEMINBRT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/MinimumBrightness/text()")
SOURCEMAXBRT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/PeakBrightness/text()")
echo "Picture source theoritical min,max brightness: $SOURCEMINBRT,$SOURCEMAXBRT nits"
[ "$SOURCEMINBRT" -gt 1 ] && echo "Source declared minimum brightness ($SOURCEMINBRT) value should be inferior to 1nit"
[ "$SOURCEMAXBRT" != 10000 ] && echo "Source declared maximum brightness ($SOURCEMAXBRT) value should be 10000 nits"
[ "$SOURCEMAXBRT" -le "$SOURCEMINBRT" ] && echo "non coherent min max theoritical picture source brightness values declared"

#Outputs/Output/video/ColorEncoding/<BitDepth>16 résolution de la dynamique du signal, doit coresspondre au fichier source
SOURCEBITDEPTH=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/BitDepth/text()")
echo "Source declared bit depth: $SOURCEBITDEPTH"
#Outputs/Output/video/ColorEncoding/<ColorSpace>rgb interpretation chromatique des composantes colorimétriques de la source image (doit correspondre au fichier source)
SOURCECOLORCOMP=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/ColorSpace/text()")
echo "Source declared color components: $SOURCECOLORCOMP"
#Outputs/Output/video/ColorEncoding/<ChromaFormat>444 quantification (si RGB doit être 444 & doit correspondre au fichier source dans tous les cas doit être 444)
SOURCECHROMAFORMAT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/ChromaFormat/text()")
echo "Source declared chromat quantification is: $(echo "$SOURCECHROMAFORMAT" | sed 's/\([0-9]\)\([0-9]\)\([0-9]\)/\1:\2:\3/g')"
#Outputs/Output/video/ColorEncoding/<SignalRange>computer (paramètre indéfinit, doit correspondre au fichier source et dans l'idéal doit toujours être en full (0N à 1024B)
SOURCESIGRANGE=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/SignalRange/text()")
echo "Source declared signal range is: $SOURCESIGRANGE"
# level 6 optionnel, valeur MaxFALL (Frame Average Light Level) MaxCLL (Max Constant Light Level), simplement afficher, si 0 0  MaxFALL > MaxCLL & Max FALL MaxCLL < Mastering display PK brt
OPTMAXFALL=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/Level6/MaxFALL/text()")
OPTMAXCLL=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/Level6/MaxCLL/text()")
echo -e "Level6 = Optionnal Max FALL & Max CLL measurement for the whole program duration:\nMaxFall = $OPTMAXFALL\nMaxCLL = $OPTMAXCLL"
[ "$OPTMAXFALL" = 0 ] && [ "$OPTMAXCLL" = "$OPTMAXFALL" ] && echo "Max FLL and Max CLL values haven't been injected into Dolby Vision CM metadata as per level 6" 
[ "$OPTMAXFALL" != 0 ] && [ "$OPTMAXFALL" -ge "$OPTMAXCLL" ] && echo "non-coherent Max FALL and Max CLL value declaration. MaxFALL cannot bu greater or equal to MaxCLL"
# [ "$OPTMAXCLL" -gt "$MDMAXBRT" ] && echo "Measured max CLL (maximum peak brightness ever measured on whole program for a given pixel cannot be greater than the declared maximum peak brightness value of the mastering display"

#Declaration Mastering Display


#/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics level="0"/<MasteringDisplay level="0">/<Name>
# afficher et garder en mémoire les caracteristiques du mastering display: 
MD=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics [@level ='0']/MasteringDisplay [@level = '0']/Name/text()")
echo "Mastering display signature: $MD"
MDMAXNIT=$(echo "$MD" | sed 's/\([0-9]*\)-nit.*$/\1/')
echo "Mastering display maximum brightness is: $MDMAXNIT nits."
MDCOLORSPACE=$(echo "$MD" | sed 's/.*-nit,\s\([^,]*\),.*$/\1/ ')
echo "Mastering display color space is: $MDCOLORSPACE."
MDWHITEPOINT=$(echo "$MD" | sed 's/.*-nit,\s[^,]*,\s\([^,]*\),.*$/\1/ ')
echo "Mastering display white point is: $MDWHITEPOINT."
MDEOTF=$(echo "$MD" | sed 's/.*-nit,\s[^,]*,\s[^,]*,\s\([^,]*\),.*$/\1/ ')
echo "Mastering display EOTF is: $MDEOTF."
MDSIGRANGE=$(echo "$MD" | sed 's/.*-nit,\s[^,]*,\s[^,]*,\s[^,]*,\s\([^,]*\)$/\1/')
echo "Mastering display signal range is: $MDSIGRANGE."
#Comparer l'espace couleur avec celui déclarer à l'image
#Comparer le WP à celui déclarer à l'image
#comparer l'EOTF à celui déclarer à l'image

#Déclaration Target Display

#Compter le nombre de target display. Si il y en a qu'un vérifier qu'il s'agit bien du TID=1 (100-nit, BT.709, BT.1886, Full) Metafier fait le reste.
#count(/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics level="0"/TargetDisplay level="0")



# afficher pour le fun les infos du target display 1
TID1=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics [@level ='0']/TargetDisplay [@level = '0']/Name/text()")
echo "Target display number 1 (SDR target) signature: $TID1"
TID1MAXNIT=$(echo "$TID1" | sed 's/\([0-9]*\)-nit.*$/\1/')
echo "Target display number 1 (SDR target) maximum brightness is: $TID1MAXNIT nits."
TID1COLORSPACE=$(echo "$TID1" | sed 's/.*-nit,\s\([^,]*\),.*$/\1/ ')
echo "Target display number 1 (SDR target) color space is: $TID1COLORSPACE."
TID1EOTF=$(echo "$TID1" | sed 's/.*-nit,\s[^,]*,\s\([^,]*\),.*$/\1/ ')
echo "Target display number 1 (SDR target) EOTF is: $TID1EOTF."
TID1SIGRANGE=$(echo "$TID1" | sed 's/.*-nit,\s[^,]*,\s[^,]*,\s\([^,]*\)$/\1/')
echo "Target display number 1 (SDR target) signal range is: $TID1SIGRANGE."

TID1WHITEPOINT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics [@level ='0']/TargetDisplay [@level = '0']/WhitePoint/text()" )
TID1WHITEPOINTx=$(echo $TID1WHITEPOINT | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
TID1WHITEPOINTy=$(echo $TID1WHITEPOINT | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
TID1WHITEPOINT="$TID1WHITEPOINTx"",""$TID1WHITEPOINTy"
echo "Target display number 1 (SDR target) declared white point chromaticities coordinates are: $TID1WHITEPOINT"
[ "$TID1WHITEPOINT" == "0.3127,0.329" ] && echo "Target display number 1 (SDR target) is declared for a D65 white point master target display."	
[ "$TID1WHITEPOINT" != "0.3127,0.329" ] && echo "Target display number 1 (SDR target) white point declaration is not clearly identified."
	

#----- SHOTS METADATA DOLBY VISION CMv2.0.5 METADATA
# METADATA SHOT COUNTS
CMSHOTS=$(parseXML "count(//Shot)")
echo "Number of metadatashot: $CMSHOTS".
# CSV print of all shots (FRAMESTART;FRAME DURATION;FRAMEEND;TCIN;TCOUT;MinPQ;AvgPQ;MaxPQ;TID;...WIP
IFS=$'\n'
FRAMEINS=($(parseXML "//Shot/Record/In/text()"))
FRAMEDURATIONS=($(parseXML "//Shot/Record/Duration/text()"))
IMAGECHARACTERISTICS=($(parseXML "//Shot/PluginNode/DolbyEDR [@level="1"]/ImageCharacter/text()"))
IFS="$OLDIFS"


for SHOTN in "${!FRAMEINS[@]}"; do
  ((FRAMEOUTS[$SHOTN]=${FRAMEINS[$SHOTN]}+${FRAMEDURATIONS[$SHOTN]}-1)) 
  if [[ ${IMAGECHARACTERISTICS[$SHOTN]} =~ ([0-9.]*),([0-9.]*),([0-9.]*) ]]; then
    MINPQ[$SHOTN]=${BASH_REMATCH[1]}
    AVGPQ[$SHOTN]=${BASH_REMATCH[2]}
    MAXPQ[$SHOTN]=${BASH_REMATCH[3]}
  fi
  # MINPQ[$SHOTN]=$(echo ${IMAGECHARACTERISTICS[$SHOTN]} | sed 's/^\([0-9.]*\),[0-9.]*,[0-9.]*$/\1/')
  # AVGPQ[$SHOTN]=$(echo ${IMAGECHARACTERISTICS[$SHOTN]} | sed 's/^[0-9.]*,\([0-9.]*\),[0-9.]*$/\1/')
  # MAXPQ[$SHOTN]=$(echo ${IMAGECHARACTERISTICS[$SHOTN]} | sed 's/^[0-9.]*,[0-9.]*,\([0-9.]*\)$/\1/')
  printf "in: %d out: %d duration: %d Lvl1-- min:%b avg:%b max:%b\n" "${FRAMEINS[$SHOTN]}" "${FRAMEOUTS[$SHOTN]}" "${FRAMEDURATIONS[$SHOTN]}" "${MINPQ[$SHOTN]}" "${AVGPQ[$SHOTN]}" "${MAXPQ[$SHOTN]}"
done








# METADATA SHOT COUNTS FOR minPQ=0




 

## Restoring IFS
IFS="$OLDIFS"
unset OLDIFS