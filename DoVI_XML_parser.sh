#!/bin/bash

# DoVI XML parser retourne dans un fichier texte des atoms predictifs d'un XML géneré par DaVinci 
# contenant toutes les informations metadatas Dolby Vision d'une timeline
# DoVI XML parser permet aussi de réaliser des test logiques sur le contenu de l'XML
INPUTXML=$1
XML=$(cat $INPUTXML)
OLDIFS="$IFS"

# FUNCTIONS
parseXML()
{
  local XPATH=$1
  echo "$XML" | xmllint --xpath "$XPATH" -
}

function populateDoVIMetaList()
{
local ARG2=$2
local INDEX=$1
local SHOTN=INDEX+1
if [[ "$INDEX" == "init" ]]; then
  CSVARRAY[0]=$(echo "MetaScope;Shot#;FrameIn;FrameOut;Duration;L1 Status;minPQ;avgPQ;maxPQ;L2 Status;L1 min offset;L1 avg offset;L1 max offset;Lift;Gain;Gamma;Saturation;Chrome;Tone Detail")
else
  if [[ $ARG2 == "Shot" ]]; then
  CSVARRAY[((${FRAMEINS[$INDEX]}+1))]=$(echo "Shot;$INDEX;${FRAMEINS[$INDEX]};${FRAMEOUTS[$INDEX]};${FRAMEDURATIONS[$INDEX]};${L1Status[$INDEX]};${MINPQ[$INDEX]};${AVGPQ[$INDEX]};${MAXPQ[$INDEX]};${LE2TID1Status[$INDEX]};${L2TIDl1minoffset[$INDEX]};${L2TIDl1avgoffset[$INDEX]};${L2TIDl1maxoffset[$INDEX]};${L2TIDlift[$INDEX]};${L2TIDgain[$INDEX]};${L2TIDgamma[$INDEX]};${L2TIDsaturation[$INDEX]};${L2TIDchroma[$INDEX]};${L2TIDToneDetail[$INDEX]}")
  elif [[ $ARG2 == "FrameOffset" ]]; then
  CSVARRAY[((${XFADEFRAMEINS[$INDEX]}+1))]=$(echo "Frame;;${XFADEFRAMEINS[$INDEX]};;;${XL1Status[$INDEX]};${XMINPQ[$INDEX]};${XAVGPQ[$INDEX]};${XMAXPQ[$INDEX]};${XLE2TID1Status[$INDEX]};${XL2TIDl1minoffset[$INDEX]};${XL2TIDl1avgoffset[$INDEX]};${XL2TIDl1maxoffset[$INDEX]};${XL2TIDlift[$INDEX]};${XL2TIDgain[$INDEX]};${XL2TIDgamma[$INDEX]};${XL2TIDsaturation[$INDEX]};${XL2TIDchroma[$INDEX]};${XL2TIDToneDetail[$INDEX]}")
  fi
fi
}

function doViMetaListToCSV ()
{
rm "$METADATANAME""_DoVIMeta.csv"
for LINE in ${!CSVARRAY[@]}
do
  echo "${CSVARRAY[$LINE]}">>"$METADATANAME""_DoVIMeta.csv"
done
}
# Revision history#


#---- is this a revised version ? (number of <revision> node. if 1 it is the fisrt version ever generated
#---- if not, display last history by DATE/AUTHOR/SOFTWARE/SOFTWAREVERSION
# MODIFIEDDATE=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/DateTime")
# AUTHOR=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/Author")
# SOFTWARE=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/Software")
# SOFTWAREV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[last()]/SoftwareVersion")
# [ $REVISIONCOUNT = 1 ] && echo "This is the first version ever generated by this software: $AUTHOR -- $SOFTWARE -- $SOFTWAREV on $MODIFIEDDATE" 
#---- if it is, display all history by HISTORYNUMBER/DATE/AUTHOR/SOFTWARE/SOFTWAREVERSION

# let I=1
# if [ $REVISIONCOUNT > 1 ]; then
  # echo "There are $REVISIONCOUNT version:"
  # while [ $I -le $REVISIONCOUNT ]
    # do
    # MODIFIEDDATEnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/DateTime")
    # AUTHORnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/Author")
    # SOFTWAREnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/Software")
    # SOFTWAREVnV=$(parseXML "/DolbyLabsMDF/RevisionHistory/Revision[$I]/SoftwareVersion")
    # echo "DoVI color mapping saved version $I generated on $MODIFIEDDATEnV by: $AUTHORnV -- $SOFTWAREnV -- $SOFTWAREVnV" 
    # let I=I+1
  # done
# fi
REVISIONCOUNT=$(parseXML "count(/DolbyLabsMDF/RevisionHistory/Revision)")

IFS=$'\n'
SOFTWAREVS=($(parseXML "/DolbyLabsMDF/RevisionHistoryRevision/Software/text()"))
MODIFIEDDATEVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/DateTime/text()"))
AUTHORVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/Author/text()"))
SOFTWAREVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/Software/text()"))
SOFTWAREVERSIONVS=($(parseXML "/DolbyLabsMDF/RevisionHistory/Revision/SoftwareVersion/text()"))
IFS=$OLDIFS

let I=1
if [ $REVISIONCOUNT > 1 ]; then
  echo "There are $REVISIONCOUNT versions:"
  while [ $I -le $REVISIONCOUNT ]
    do
    echo "DoVI metadata XML's version file number $I generated on ${MODIFIEDDATEVS[((I-1))]} by: ${AUTHORVS[((I-1))]} -- ${SOFTWAREVS[((I-1))]} -- ${MODIFIEDDATEVS[((I-1))]}"
    let I=I+1
    done
  else
  echo " This is the first version of the DoVI metadata XML's file generated on ${MODIFIEDDATEVS[last()]} by: ${AUTHORVS[last()]} -- ${SOFTWAREVS[last()]} -- ${MODIFIEDDATEVS[last()]}"
fi


#---- Outputs

# nom de la metadata Outputs/Output[name=.*]
METADATANAME=$(parseXML "/DolbyLabsMDF/Outputs/Output/@name" | sed 's/name="\(.*\)"$/\1/')
echo "DoVi CM metadata filename is: $METADATANAME"
# version de la metadata (2.0.5, 4.0.2 ...)
CMV=$(parseXML "/DolbyLabsMDF/@version" | sed 's/.*="\([0-9.]*\)".*/\1/')
echo "Metadata version is CMv=$CMV"
# param cadre diffuser (à afficher et convertir en ligne*pix) Outputs/output/CanvasAspectRatio
CANVASASPECTRATIO=$(parseXML "/DolbyLabsMDF/Outputs/Output/CanvasAspectRatio/text()")
echo "Canvas aspect ratio is: $CANVASASPECTRATIO"  
# param cadre util (à afficher et convertir en ligne*pix) Outputs/output/ImageAspectRatio
IMAGEASPECTRATIO=$(parseXML "/DolbyLabsMDF/Outputs/Output/ImageAspectRatio/text()")
echo "Image aspect ratio is: $IMAGEASPECTRATIO" 
# Outputs/Output/video/rate   cadence image de la metadata(<n>f</n>p<d>s</d>)
METAFRAMERATEN=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/Rate/n/text()")
METAFRAMERATED=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/Rate/d/text()")
let METAFRAMERATE="METAFRAMERATEN / METAFRAMERATED"
echo "DoVi metadatas are set at $METAFRAMERATE fps"
#Outputs/Output/video/ColorEncoding/Primaries/Red /Green /Blue (arg: x,y) déclaration des extremes colorimétriques du VDM
SOURCECOLORSPACER=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Primaries/Red/text()")
SOURCECOLORSPACEG=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Primaries/Green/text()")
SOURCECOLORSPACEB=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Primaries/Blue/text()")
#4 Scenaris based on 3 color space REC703, P3, REC 2020, Unknown
SOURCECOLORSPACERx=$(echo $SOURCECOLORSPACER | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACERy=$(echo $SOURCECOLORSPACER | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACER="$SOURCECOLORSPACERx"",""$SOURCECOLORSPACERy"

SOURCECOLORSPACEGx=$(echo $SOURCECOLORSPACEG | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEGy=$(echo $SOURCECOLORSPACEG | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEG="$SOURCECOLORSPACEGx"",""$SOURCECOLORSPACEGy"

SOURCECOLORSPACEBx=$(echo $SOURCECOLORSPACEB | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEBy=$(echo $SOURCECOLORSPACEB | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCECOLORSPACEB="$SOURCECOLORSPACEBx"",""$SOURCECOLORSPACEBy"
echo "Picture source declared primaries chromaticities coordinates are:"
echo "R(x,y) $SOURCECOLORSPACER"
echo "G(x,y) $SOURCECOLORSPACEG"
echo "B(x,y) $SOURCECOLORSPACEB"
[ "$SOURCECOLORSPACER" == "0.64,0.33" ] && [ "$SOURCECOLORSPACEG" == "0.3,0.6" ] && [ "$SOURCECOLORSPACEB" == "0.15,0.06" ] && SOURCECOLORSPACE="REC709" && echo "Picture source is declared for a REC.709 master target display." 
[ "$SOURCECOLORSPACER" == "0.68,0.32" ] && [ "$SOURCECOLORSPACEG" == "0.265,0.69" ] && [ "$SOURCECOLORSPACEB" == "0.15,0.06" ] && SOURCECOLORSPACE="P3" && echo "Picture source is declared for a P3 master target display." 
[ "$SOURCECOLORSPACER" == "0.708,0.292" ] && [ "$SOURCECOLORSPACEG" == "0.17,0.797" ] && [ "$SOURCECOLORSPACEB" == "0.131,0.046" ] && SOURCECOLORSPACE="REC2020" && echo "Picture source is declared for a REC.2020 master target display."
[ "$SOURCECOLORSPACE" != "REC709" ] && [ "$SOURCECOLORSPACE" != "P3" ] && [ "$SOURCECOLORSPACE" != "REC2020" ] && echo "Unknown color primaries declaration" && SOURCECOLORSPACE="NA"

# à determiner par rapport au diagramme de chromaticité 1331 (P3 BT.2020 REC.709, Unknown)
#Outputs/Output/video/ColorEncoding/WhitePoint coordonée point blanc (arg:x,y) à pointer et determiner selon Chrom 1331 (D65,D60, DCI, unknown)
SOURCEWHITEPOINT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/WhitePoint/text()")
SOURCEWHITEPOINTx=$(echo $SOURCEWHITEPOINT | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCEWHITEPOINTy=$(echo $SOURCEWHITEPOINT | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
SOURCEWHITEPOINT="$SOURCEWHITEPOINTx"",""$SOURCEWHITEPOINTy"
echo "Picture source declared white point chromaticities coordinates are: $SOURCEWHITEPOINT"
[ "$SOURCEWHITEPOINT" == "0.3127,0.329" ] && echo "Picture source is declared for a D65 white point master target display."	
[ "$SOURCEWHITEPOINT" != "0.3127,0.329" ] && echo "Picture source white point declaration is not clearly identified."
#Outputs/Output/video/ColorEncoding/Encoding doit être identifié en "PQ" (Perceptual Quantizer)
SOURCEEOTF=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/Encoding/text()")
echo "Picture source declared EOTF is: $SOURCEEOTF"
[ "$SOURCEEOTF" != "pq" ] && echo "Picture source declared EOTF ($SOURCEEOTF) is not compliant with Dolby Vision CM workflow."
#Outputs/Output/video/ColorEncoding/<MinimumBrightness>0 (echelle absolue de la dynamique du luminance idéale dit être inférieur à 1nits)
#Outputs/Output/video/ColorEncoding/<PeakBrightness>10000 (echelle absolue de la dynamique du luminance idéale doit être égale à 10000nits)
SOURCEMINBRT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/MinimumBrightness/text()")
SOURCEMAXBRT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/PeakBrightness/text()")
echo "Picture source theoritical min,max brightness: $SOURCEMINBRT,$SOURCEMAXBRT nits"
[ "$SOURCEMINBRT" -gt 1 ] && echo "Source declared minimum brightness ($SOURCEMINBRT) value should be inferior to 1nit"
[ "$SOURCEMAXBRT" != 10000 ] && echo "Source declared maximum brightness ($SOURCEMAXBRT) value should be 10000 nits"
[ "$SOURCEMAXBRT" -le "$SOURCEMINBRT" ] && echo "non coherent min max theoritical picture source brightness values declared"

#Outputs/Output/video/ColorEncoding/<BitDepth>16 résolution de la dynamique du signal, doit coresspondre au fichier source
SOURCEBITDEPTH=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/BitDepth/text()")
echo "Source declared bit depth: $SOURCEBITDEPTH"
#Outputs/Output/video/ColorEncoding/<ColorSpace>rgb interpretation chromatique des composantes colorimétriques de la source image (doit correspondre au fichier source)
SOURCECOLORCOMP=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/ColorSpace/text()")
echo "Source declared color components: $SOURCECOLORCOMP"
#Outputs/Output/video/ColorEncoding/<ChromaFormat>444 quantification (si RGB doit être 444 & doit correspondre au fichier source dans tous les cas doit être 444)
SOURCECHROMAFORMAT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/ChromaFormat/text()")
echo "Source declared chromat quantification is: $(echo "$SOURCECHROMAFORMAT" | sed 's/\([0-9]\)\([0-9]\)\([0-9]\)/\1:\2:\3/g')"
#Outputs/Output/video/ColorEncoding/<SignalRange>computer (paramètre indéfinit, doit correspondre au fichier source et dans l'idéal doit toujours être en full (0N à 1024B)
SOURCESIGRANGE=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track/ColorEncoding/SignalRange/text()")
echo "Source declared signal range is: $SOURCESIGRANGE"
# level 6 optionnel, valeur MaxFALL (Frame Average Light Level) MaxCLL (Max Constant Light Level), simplement afficher, si 0 0  MaxFALL > MaxCLL & Max FALL MaxCLL < Mastering display PK brt
OPTMAXFALL=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/Level6/MaxFALL/text()")
OPTMAXCLL=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/Level6/MaxCLL/text()")
echo -e "Level6 = Optionnal Max FALL & Max CLL measurement for the whole program duration:\nMaxFall = $OPTMAXFALL\nMaxCLL = $OPTMAXCLL"
[ "$OPTMAXFALL" = 0 ] && [ "$OPTMAXCLL" = "$OPTMAXFALL" ] && echo "Max FLL and Max CLL values haven't been injected into Dolby Vision CM metadata as per level 6" 
[ "$OPTMAXFALL" != 0 ] && [ "$OPTMAXFALL" -ge "$OPTMAXCLL" ] && echo "non-coherent Max FALL and Max CLL value declaration. MaxFALL cannot bu greater or equal to MaxCLL"
# [ "$OPTMAXCLL" -gt "$MDMAXBRT" ] && echo "Measured max CLL (maximum peak brightness ever measured on whole program for a given pixel cannot be greater than the declared maximum peak brightness value of the mastering display"

#Declaration Mastering Display


#/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics level="0"/<MasteringDisplay level="0">/<Name>
# afficher et garder en mémoire les caracteristiques du mastering display: 
MD=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics [@level ='0']/MasteringDisplay [@level = '0']/Name/text()")
echo "Mastering display signature: $MD"
MDMAXNIT=$(echo "$MD" | sed 's/\([0-9]*\)-nit.*$/\1/')
echo "Mastering display maximum brightness is: $MDMAXNIT nits."
MDCOLORSPACE=$(echo "$MD" | sed 's/.*-nit,\s\([^,]*\),.*$/\1/ ')
echo "Mastering display color space is: $MDCOLORSPACE."
MDWHITEPOINT=$(echo "$MD" | sed 's/.*-nit,\s[^,]*,\s\([^,]*\),.*$/\1/ ')
echo "Mastering display white point is: $MDWHITEPOINT."
MDEOTF=$(echo "$MD" | sed 's/.*-nit,\s[^,]*,\s[^,]*,\s\([^,]*\),.*$/\1/ ')
echo "Mastering display EOTF is: $MDEOTF."
MDSIGRANGE=$(echo "$MD" | sed 's/.*-nit,\s[^,]*,\s[^,]*,\s[^,]*,\s\([^,]*\)$/\1/')
echo "Mastering display signal range is: $MDSIGRANGE."
#Comparer l'espace couleur avec celui déclarer à l'image
#Comparer le WP à celui déclarer à l'image
#comparer l'EOTF à celui déclarer à l'image

#Déclaration Target Display

#Compter le nombre de target display. Si il y en a qu'un vérifier qu'il s'agit bien du TID=1 (100-nit, BT.709, BT.1886, Full) Metafier fait le reste.
#count(/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics level="0"/TargetDisplay level="0")



# afficher pour le fun les infos du target display 1
TID1=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics [@level ='0']/TargetDisplay [@level = '0']/Name/text()")
echo "Target display number 1 (SDR target) signature: $TID1"
TID1MAXNIT=$(echo "$TID1" | sed 's/\([0-9]*\)-nit.*$/\1/')
echo "Target display number 1 (SDR target) maximum brightness is: $TID1MAXNIT nits."
TID1COLORSPACE=$(echo "$TID1" | sed 's/.*-nit,\s\([^,]*\),.*$/\1/ ')
echo "Target display number 1 (SDR target) color space is: $TID1COLORSPACE."
TID1EOTF=$(echo "$TID1" | sed 's/.*-nit,\s[^,]*,\s\([^,]*\),.*$/\1/ ')
echo "Target display number 1 (SDR target) EOTF is: $TID1EOTF."
TID1SIGRANGE=$(echo "$TID1" | sed 's/.*-nit,\s[^,]*,\s[^,]*,\s\([^,]*\)$/\1/')
echo "Target display number 1 (SDR target) signal range is: $TID1SIGRANGE."

TID1WHITEPOINT=$(parseXML "/DolbyLabsMDF/Outputs/Output/Video/Track[@name]/PluginNode/DolbyEDR/Characteristics [@level ='0']/TargetDisplay [@level = '0']/WhitePoint/text()" )
TID1WHITEPOINTx=$(echo $TID1WHITEPOINT | sed 's/\([0-9\.]\),.*/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
TID1WHITEPOINTy=$(echo $TID1WHITEPOINT | sed 's/.*,\([0-9\.]\)/\1/' | sed 's/^\(0,[0-9]*[1-9]\)0*$/\1/')
TID1WHITEPOINT="$TID1WHITEPOINTx"",""$TID1WHITEPOINTy"
echo "Target display number 1 (SDR target) declared white point chromaticities coordinates are: $TID1WHITEPOINT"
[ "$TID1WHITEPOINT" == "0.3127,0.329" ] && echo "Target display number 1 (SDR target) is declared for a D65 white point master target display."	
[ "$TID1WHITEPOINT" != "0.3127,0.329" ] && echo "Target display number 1 (SDR target) white point declaration is not clearly identified."
	

#----- SHOTS METADATA DOLBY VISION CMv2.0.5 METADATA
# METADATA SHOT COUNTS
CMSHOTS=$(parseXML "count(//Shot)")
echo "Number of metadatashot: $CMSHOTS".
# CSV print of all shots (FRAMESTART;FRAME DURATION;FRAMEEND;TCIN;TCOUT;MinPQ;AvgPQ;MaxPQ;TID;...WIP
IFS=$'\n'
SHOTUUID=($(parseXML "//Shot/UniqueID/text()"))
FRAMEINS=($(parseXML "//Shot/Record/In/text()"))
FRAMEDURATIONS=($(parseXML "//Shot/Record/Duration/text()"))
IMAGECHARACTERISTICS=($(parseXML "//Shot/PluginNode/DolbyEDR [@level="1"]/ImageCharacter/text()"))
L2TID1=($(parseXML "//Shot/PluginNode/DolbyEDR [@level="2"] [TID=1]/Trim/text()"))
# L2 param: L1minOffset,L1avgOffset,L&MaxOffset,Lift,Gain,Gamma,Saturation,Chroma,Tone Detail
IFS="$OLDIFS"

populateDoVIMetaList init
for SHOTN in "${!SHOTUUID[@]}"; do
  ((FRAMEOUTS[$SHOTN]=${FRAMEINS[$SHOTN]}+${FRAMEDURATIONS[$SHOTN]}-1)) 
  if [[ -z ${IMAGECHARACTERISTICS[$SHOTN]} ]]; then
    L1Status[$SHOTN]="Not Defined"
    MINPQ[$SHOTN]=""
    AVGPQ[$SHOTN]=""
    MAXPQ[$SHOTN]=""
  elif [[ ${IMAGECHARACTERISTICS[$SHOTN]} =~ ([0-9.]*),([0-9.]*),([0-9.]*) ]]; then
      MINPQ[$SHOTN]=${BASH_REMATCH[1]}
      AVGPQ[$SHOTN]=${BASH_REMATCH[2]}
      MAXPQ[$SHOTN]=${BASH_REMATCH[3]}
  fi
  if [[ -z ${L2TID1[$SHOTN]} ]]; then
    LE2TID1Status[$SHOTN]="Not Defined"
    L2TIDl1minoffset[$SHOTN]=""
    L2TIDl1avgoffset[$SHOTN]=""
    L2TIDl1maxoffset[$SHOTN]=""
    L2TIDlift[$SHOTN]=""
    L2TIDgain[$SHOTN]=""
    L2TIDgamma[$SHOTN]=""
    L2TIDsaturation[$SHOTN]=""
    L2TIDchroma[$SHOTN]=""
    L2TIDToneDetail[$SHOTN]=""
  elif [[ ${L2TID1[$SHOTN]} =~ ([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*) ]]; then
    L2TIDl1minoffset[$SHOTN]=${BASH_REMATCH[1]}
    L2TIDl1avgoffset[$SHOTN]=${BASH_REMATCH[2]}
    L2TIDl1maxoffset[$SHOTN]=${BASH_REMATCH[3]}
    L2TIDlift[$SHOTN]=${BASH_REMATCH[4]}
    L2TIDgain[$SHOTN]=${BASH_REMATCH[5]}
    L2TIDgamma[$SHOTN]=${BASH_REMATCH[6]}
    L2TIDsaturation[$SHOTN]=${BASH_REMATCH[7]}
    L2TIDchroma[$SHOTN]=${BASH_REMATCH[8]}
    L2TIDToneDetail[$SHOTN]=${BASH_REMATCH[9]}
  fi
populateDoVIMetaList $SHOTN "Shot"
# printf "Shot n:%d in:%d Lvl1-- min:%b avg:%b max:%b\n" "$SHOTN" "${FRAMEINS[$SHOTN]}" "${MINPQ[$SHOTN]}" "${AVGPQ[$SHOTN]}" "${MAXPQ[$SHOTN]}"
# printf "TID1 Trim shot n:%d in: %d %b(%b,%b,%b,%b,%b,%b,%b,%b,%b)\n" "$SHOTN" "${FRAMEINS[$SHOTN]}" "${LE2TID1Status[$SHOTN]}" "${L2TIDl1minoffset[$SHOTN]}" "${L2TIDl1avgoffset[$SHOTN]}" "${L2TIDl1maxoffset[$SHOTN]}" "${L2TIDlift[$SHOTN]}" "${L2TIDgain[$SHOTN]}" "${L2TIDgamma[$SHOTN]}" "${L2TIDsaturation[$SHOTN]}" "${L2TIDchroma[$SHOTN]}" "${L2TIDToneDetail[$SHOTN]}"
done

#------Xfade (<EditOffset>) parsing
# Shot count where edit offset nodes exist
XFADESHOTSCOUNT=$(parseXML "count(//Shot[Frame/EditOffset])")
echo "There are $XFADESHOTSCOUNT shots where Dovi metadata per frame (of an existing fade editing) are applied"

#Edit Offset. Level 1 and potential Level 2 Parsing
IFS=$'\n'
XFADESHOTUUID=($(parseXML "//Shot[Frame/EditOffset[last()]]/UniqueID/text()"))
XFADEFRAMEENTRIES=($(parseXML "//Shot/Frame/EditOffset/text()"))
XFADEIMAGECHARACTERISTICS=($(parseXML "//Shot/Frame/PluginNode/DolbyEDR [@level="1"]/ImageCharacter/text()"))
XFADEL2TID1=($(parseXML "//Shot/Frame/PluginNode/DolbyEDR [@level="2"] [TID=1]/Trim/text()"))
# L2 param: L1minOffset,L1avgOffset,L&MaxOffset,Lift,Gain,Gamma,Saturation,Chroma,Tone Detail
XFADESHOTFRAMEINS=($(parseXML "//Shot[Frame/EditOffset]/Record/In/text()"))
XFADESHOTUUIDS=($(parseXML "//Shot[Frame/EditOffset]/UniqueID/text()"))
IFS="$OLDIFS"

#--------
#Determiner le numéro d'image en entrée pour chaque plan composé de frame offset

#pour chacun de ces plans determiner le nombre de frame offset
for XFADESHOTINDEX in ${!XFADESHOTFRAMEINS[@]}; do
    XFADEFRAMEOFFSETCOUNT[XFADESHOTINDEX]=$(parseXML "count(//Shot[Record/In="${XFADESHOTFRAMEINS[$XFADESHOTINDEX]}"]/Frame/EditOffset)")
# echo "$XFADESHOTINDEX -${XFADESHOTFRAMEINS[$XFADESHOTINDEX]} - ${XFADEFRAMEOFFSETCOUNT[$XFADESHOTINDEX]}"
done
#Pour chacun de ces plans sommer l'image d'entrée avec toutes les valeurs frame offsets correspondant
((XFADESHOTINDEX=0))
((XFADEFRAMEINDEX=0))
((LastXFADEFRAMETOTAL=0))

for XFADEFRAMECOUNT in ${XFADEFRAMEOFFSETCOUNT[@]}; do
# echo "loop 2 nombre d'image de Xfade de ce plan"
  ((XFADEFRAMETOTAL=$XFADEFRAMECOUNT+$LastXFADEFRAMETOTAL))
  while [ $XFADEFRAMEINDEX -lt $XFADEFRAMETOTAL ]; do
    # echo "Addition autant qu'il y a d'images xfade dans ce plan"
    ((XFADEFRAMEINS[XFADEFRAMEINDEX]=${XFADESHOTFRAMEINS[$XFADESHOTINDEX]}+${XFADEFRAMEENTRIES[$XFADEFRAMEINDEX]}))
    # echo "I:$XFADEFRAMEINDEX Shot:$XFADESHOTINDEX ShotFramein:${XFADESHOTFRAMEINS[$XFADESHOTINDEX]} Xfadeentry:${XFADEFRAMEENTRIES[$XFADEFRAMEINDEX]} XfadeFramein:${XFADEFRAMEINS[$XFADEFRAMEINDEX]}"
    ((XFADEFRAMEINDEX=$XFADEFRAMEINDEX+1))
  done
  ((LastXFADEFRAMETOTAL=$XFADEFRAMETOTAL))
  ((XFADESHOTINDEX=$XFADESHOTINDEX+1))
done

for XFADEFRAMEN in "${!XFADEFRAMEINS[@]}"; do
  if [[ -z ${XFADEIMAGECHARACTERISTICS[$XFADEFRAMEN]} ]]; then
    XL1Status[$XFADEFRAMEN]="Not Defined"
    XMINPQ[$XFADEFRAMEN]=""
    XAVGPQ[$XFADEFRAMEN]=""
    XMAXPQ[$XFADEFRAMEN]=""
  elif [[ ${XFADEIMAGECHARACTERISTICS[$XFADEFRAMEN]} =~ ([0-9.]*),([0-9.]*),([0-9.]*) ]]; then
      XMINPQ[$XFADEFRAMEN]=${BASH_REMATCH[1]}
      XAVGPQ[$XFADEFRAMEN]=${BASH_REMATCH[2]}
      XMAXPQ[$XFADEFRAMEN]=${BASH_REMATCH[3]}
  fi
  if [[ -z ${XFADEL2TID1[$XFADEFRAMEN]} ]]; then
    XLE2TID1Status[$XFADEFRAMEN]="Not Defined"
    XL2TIDl1minoffset[$XFADEFRAMEN]=""
    XL2TIDl1avgoffset[$XFADEFRAMEN]=""
    XL2TIDl1maxoffset[$XFADEFRAMEN]=""
    XL2TIDlift[$XFADEFRAMEN]=""
    XL2TIDgain[$XFADEFRAMEN]=""
    XL2TIDgamma[$XFADEFRAMEN]=""
    XL2TIDsaturation[$XFADEFRAMEN]=""
    XL2TIDchroma[$XFADEFRAMEN]=""
    XL2TIDToneDetail[$XFADEFRAMEN]=""
  elif [[ ${XFADEL2TID1[$XFADEFRAMEN]} =~ ([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*),([0-9.\-]*) ]]; then
      XL2TIDl1minoffset[$XFADEFRAMEN]=${BASH_REMATCH[1]}
      XL2TIDl1avgoffset[$XFADEFRAMEN]=${BASH_REMATCH[2]}
      XL2TIDl1maxoffset[$XFADEFRAMEN]=${BASH_REMATCH[3]}
      XL2TIDlift[$XFADEFRAMEN]=${BASH_REMATCH[4]}
      XL2TIDgain[$XFADEFRAMEN]=${BASH_REMATCH[5]}
      XL2TIDgamma[$XFADEFRAMEN]=${BASH_REMATCH[6]}
      XL2TIDsaturation[$XFADEFRAMEN]=${BASH_REMATCH[7]}
      XL2TIDchroma[$XFADEFRAMEN]=${BASH_REMATCH[8]}
      XL2TIDToneDetail[$XFADEFRAMEN]=${BASH_REMATCH[9]}
  fi
  populateDoVIMetaList $XFADEFRAMEN "FrameOffset"
done











 #Generate CSV based on $CSVARRAY
doViMetaListToCSV
## Restoring IFS
IFS="$OLDIFS"
unset OLDIFS